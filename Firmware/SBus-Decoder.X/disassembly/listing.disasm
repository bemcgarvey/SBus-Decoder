Disassembly Listing for SBus-Decoder
Generated From:
C:/Projects/SBus-Decoder/Firmware/SBus-Decoder.X/dist/default/production/SBus-Decoder.X.production.elf
Jul 17, 2021 10:41:37 PM

---  C:/Users/bemcg/AppData/Local/Temp/sajo.s  ----------------------------------------------------------
01EA  0064     CLRWDT
01EB  0180     CLRF INDF0
01EC  3101     ADDFSR 0, 1
01ED  0B89     DECFSZ WREG, F
01EE  29EB     GOTO 0x1EB
01EF  3400     RETLW 0x0
001B  3020     MOVLW 0x20
001C  0084     MOVWF FSR0
001D  3000     MOVLW 0x0
001E  0085     MOVWF FSR0H
001F  301E     MOVLW 0x1E
0020  3181     MOVLP 0x1
0023  107E     BCF 0x7E, 0x0
0024  0020     MOVLB 0x0
0025  2932     GOTO 0x132
---  C:/Projects/SBus-Decoder/Firmware/SBus-Decoder.X/timers.c  -----------------------------------------
1:             /////////////////////////////////////////////////////
2:             // Project: SBus-Decoder                           //
3:             // File: timers.h                                  //
4:             // Target: PIC16F18313                             // 
5:             // Compiler: XC8                                   //
6:             // Author: Brad McGarvey                           //
7:             // License: GNU General Public License v3.0        //
8:             // Description: Timer functions                    //
9:             /////////////////////////////////////////////////////
10:            
11:            #include <xc.h>
12:            #include <stdint.h>
13:            #include "timers.h"
14:            #include "led.h"
15:            #include "servo.h"
16:            
17:            volatile uint8_t tickCount = 0;
18:            volatile uint8_t frameTickCount = 0;
19:            
20:            void initTimer1(void) {
21:                T1CONbits.TMR1ON = 0;
01DB  0020     MOVLB 0x0
01DC  101B     BCF T1CON, 0x0
22:                T1CONbits.TMR1CS = 0b00; // Fosc / 4
01DD  303F     MOVLW 0x3F
01DE  059B     ANDWF T1CON, F
23:                T1CONbits.T1CKPS = 0b00; // 1:1 pre-scale
01DF  30CF     MOVLW 0xCF
01E0  059B     ANDWF T1CON, F
24:                T1GCONbits.TMR1GE = 0; //Gate disabled
01E1  139C     BCF T1GCON, 0x7
25:            }
01E2  0008     RETURN
26:            
27:            inline void startTimer1(void) {
28:                TMR1H = 0;
01F0  0020     MOVLB 0x0
01F1  019A     CLRF TMR1H
29:                TMR1L = 0;
01F2  0199     CLRF TMR1
30:                T1CONbits.TMR1ON = 1;
01F3  141B     BSF T1CON, 0x0
31:            }
01F4  0008     RETURN
32:            
33:            inline void stopTimer1(void) {
34:                T1CONbits.TMR1ON = 0;
01FB  0020     MOVLB 0x0
01FC  101B     BCF T1CON, 0x0
35:            }
01FD  0008     RETURN
36:            
37:            void initTimer2(void) {
38:                T2CONbits.TMR2ON = 0;
01CA  0020     MOVLB 0x0
01CB  111F     BCF T2CON, 0x2
39:                T2CONbits.T2OUTPS = 0b1001; //1:10 post-scale
01CC  081F     MOVF T2CON, W
01CD  3987     ANDLW 0x87
01CE  3848     IORLW 0x48
01CF  009F     MOVWF T2CON
40:                T2CONbits.T2CKPS = 0b01; //1:4 pre-scale
01D0  081F     MOVF T2CON, W
01D1  39FC     ANDLW 0xFC
01D2  3801     IORLW 0x1
01D3  009F     MOVWF T2CON
41:                TMR2 = 0;
01D4  019D     CLRF TMR2
42:                PR2 = 200;
01D5  30C8     MOVLW 0xC8
01D6  009E     MOVWF PR2
43:                PIR1bits.TMR2IF = 0;
01D7  1091     BCF PIR1, 0x1
44:                PIE1bits.TMR2IE = 1;
01D8  0021     MOVLB 0x1
01D9  1491     BSF PIE1, 0x1
45:            }
01DA  0008     RETURN
46:            
47:            void startTimer2(void) {
48:                T2CONbits.TMR2ON = 1;
01F5  0020     MOVLB 0x0
01F6  151F     BSF T2CON, 0x2
49:            }
01F7  0008     RETURN
50:            
51:            inline void handleTimer2Int(void) {
52:                ++tickCount;
01B6  3001     MOVLW 0x1
01B7  0020     MOVLB 0x0
01B8  00C4     MOVWF 0x44
01B9  0844     MOVF 0x44, W
01BA  07BB     ADDWF tickCount, F
53:                ++frameTickCount;
01BB  3001     MOVLW 0x1
01BC  00C4     MOVWF 0x44
01BD  0844     MOVF 0x44, W
01BE  07B7     ADDWF frameTickCount, F
54:                if (frameTickCount == 22) {
01BF  3016     MOVLW 0x16
01C0  0637     XORWF frameTickCount, W
01C1  1D03     BTFSS STATUS, 0x2
01C2  29C4     GOTO 0x1C4
01C3  29C5     GOTO 0x1C5
01C4  29C9     GOTO 0x1C9
55:                    frameTickCount = 0;
01C5  01B7     CLRF frameTickCount
56:                    startFrame();
01C6  3180     MOVLP 0x0
01C7  20ED     CALL 0xED
01C8  3181     MOVLP 0x1
57:                }
58:            }
01C9  0008     RETURN
59:            
---  C:/Projects/SBus-Decoder/Firmware/SBus-Decoder.X/servo.c  ------------------------------------------
1:             /////////////////////////////////////////////////////
2:             // Project: SBus-Decoder                           //
3:             // File: servo.c                                   //
4:             // Target: PIC16F18313                             // 
5:             // Compiler: XC8                                   //
6:             // Author: Brad McGarvey                           //
7:             // License: GNU General Public License v3.0        //
8:             // Description: Servo output functions             //
9:             /////////////////////////////////////////////////////
10:            
11:            #include <xc.h>
12:            #include <stdint.h>
13:            #include "servo.h"
14:            #include "timers.h"
15:            #include "sbus.h"
16:            
17:            void initServos(void) {
18:                CCP1CONbits.CCP1MODE = 0b1001; //Clear on match
01E3  0025     MOVLB 0x5
01E4  0813     MOVF CCP1CON, W
01E5  39F0     ANDLW 0xF0
01E6  3809     IORLW 0x9
01E7  0093     MOVWF CCP1CON
19:                CCP1CONbits.CCP1EN = 1;
01E8  1793     BSF CCP1CON, 0x7
20:            }
01E9  0008     RETURN
21:            
22:            void startFrame(void) {
23:                stopTimer1();
00ED  3181     MOVLP 0x1
00EE  21FB     CALL 0x1FB
00EF  3180     MOVLP 0x0
24:                uint32_t pulse = 8000 * throttle;
00F0  0020     MOVLB 0x0
00F1  083D     MOVF 0x3D, W
00F2  00F1     MOVWF 0x71
00F3  083C     MOVF throttle, W
00F4  00F0     MOVWF __pcstackCOMMON
00F5  3040     MOVLW 0x40
00F6  00F2     MOVWF multiplicand
00F7  301F     MOVLW 0x1F
00F8  00F3     MOVWF 0x73
00F9  3181     MOVLP 0x1
00FA  217D     CALL 0x17D
00FB  3180     MOVLP 0x0
00FC  0870     MOVF __pcstackCOMMON, W
00FD  0020     MOVLB 0x0
00FE  00C0     MOVWF pulse
00FF  0871     MOVF 0x71, W
0100  00C1     MOVWF 0x41
0101  01C2     CLRF 0x42
0102  01C3     CLRF 0x43
25:                pulse /= 2047;
0103  3000     MOVLW 0x0
0104  00F3     MOVWF 0x73
0105  3000     MOVLW 0x0
0106  00F2     MOVWF multiplicand
0107  3007     MOVLW 0x7
0108  00F1     MOVWF 0x71
0109  30FF     MOVLW 0xFF
010A  00F0     MOVWF __pcstackCOMMON
010B  0843     MOVF 0x43, W
010C  00F7     MOVWF 0x77
010D  0842     MOVF 0x42, W
010E  00F6     MOVWF 0x76
010F  0841     MOVF 0x41, W
0110  00F5     MOVWF 0x75
0111  0840     MOVF pulse, W
0112  00F4     MOVWF product
0113  3180     MOVLP 0x0
0114  2093     CALL 0x93
0115  3180     MOVLP 0x0
0116  0873     MOVF 0x73, W
0117  0020     MOVLB 0x0
0118  00C3     MOVWF 0x43
0119  0872     MOVF multiplicand, W
011A  00C2     MOVWF 0x42
011B  0871     MOVF 0x71, W
011C  00C1     MOVWF 0x41
011D  0870     MOVF __pcstackCOMMON, W
011E  00C0     MOVWF pulse
26:                uint16_t match = 8000 + (uint16_t)pulse;
011F  0840     MOVF pulse, W
0120  3E40     ADDLW 0x40
0121  00BE     MOVWF __pcstackBANK0
0122  301F     MOVLW 0x1F
0123  3D41     ADDWFC 0x41, W
0124  00BF     MOVWF 0x3F
27:                CCPR1 = match;
0125  083F     MOVF 0x3F, W
0126  0025     MOVLB 0x5
0127  0092     MOVWF CCPR1H
0128  0020     MOVLB 0x0
0129  083E     MOVF __pcstackBANK0, W
012A  0025     MOVLB 0x5
012B  0091     MOVWF CCPR1
28:                LATAbits.LATA0 = 1;
012C  0022     MOVLB 0x2
012D  140C     BSF LATA, 0x0
29:                startTimer1();
012E  3181     MOVLP 0x1
012F  21F0     CALL 0x1F0
0130  3180     MOVLP 0x0
30:            }
0131  0008     RETURN
---  C:/Projects/SBus-Decoder/Firmware/SBus-Decoder.X/sbus.c  -------------------------------------------
1:             /////////////////////////////////////////////////////
2:             // Project: SBus-Decoder                           //
3:             // File: sbus.c                                    //
4:             // Target: PIC16F18313                             // 
5:             // Compiler: XC8                                   //
6:             // Author: Brad McGarvey                           //
7:             // License: GNU General Public License v3.0        //
8:             // Description: SBus functions                     //
9:             /////////////////////////////////////////////////////
10:            
11:            #include <xc.h>
12:            #include <stdint.h>
13:            #include "sbus.h"
14:            #include "timers.h"
15:            #include "led.h"
16:            
17:            #define SBUS_HEADER 0x0f
18:            #define SBUS_FOOTER 0x00
19:            
20:            volatile SBusPacket rxPacket;
21:            volatile uint8_t currentByte = 0;
22:            volatile char packetUpdate = 0;
23:            volatile char receivingPacket = 0;
24:            volatile uint16_t throttle = 0;
25:            
26:            void initSBus(void) {
27:                //Setup CLC1
28:                CLC1CONbits.LC1EN = 0;
015D  003E     MOVLB 0x1E
015E  1390     BCF CLC1CON, 0x7
29:                CLC1CONbits.LC1MODE = 0b010; //AND
015F  0810     MOVF CLC1CON, W
0160  39F8     ANDLW 0xF8
0161  3802     IORLW 0x2
0162  0090     MOVWF CLC1CON
30:                CLC1SEL0 = 0;
0163  0192     CLRF CLC1SEL0
31:                CLC1SEL1 = 0;
0164  0193     CLRF CLC1SEL1
32:                CLC1SEL2 = 0;
0165  0194     CLRF CLC1SEL2
33:                CLC1SEL3 = 0;
0166  0195     CLRF CLC1SEL3
34:                CLC1POL = 0b10001110;
0167  308E     MOVLW 0x8E
0168  0091     MOVWF CLC1POL
35:                CLC1GLS0 = 0x02;
0169  3002     MOVLW 0x2
016A  0096     MOVWF CLC1GLS0
36:                CLC1GLS1 = 0;
016B  0197     CLRF CLC1GLS1
37:                CLC1GLS2 = 0;
016C  0198     CLRF CLC1GLS2
38:                CLC1GLS3 = 0;
016D  0199     CLRF CLC1GLS3
39:                CLC1CONbits.LC1EN = 1;
016E  1790     BSF CLC1CON, 0x7
40:                //Setup USART
41:                TX1STAbits.BRGH = 1;
016F  0023     MOVLB 0x3
0170  151E     BSF TX1STA, 0x2
42:                BAUD1CONbits.BRG16 = 1;
0171  159F     BSF BAUD1CON, 0x3
43:                SP1BRGH = 0;
0172  019C     CLRF SP1BRGH
44:                SP1BRGL = 79; //100000 baud at Fosc = 32 MHz
0173  304F     MOVLW 0x4F
0174  009B     MOVWF SP1BRG
45:                TX1STAbits.SYNC = 0;
0175  121E     BCF TX1STA, 0x4
46:                //BAUD1CONbits.SCKP = 1; //invert polarity
47:                RC1STAbits.SPEN = 1;
0176  179D     BSF RC1STA, 0x7
48:                RC1STAbits.RX9 = 1; //9 bit rx for parity
0177  171D     BSF RC1STA, 0x6
49:                PIE1bits.RCIE = 1;
0178  0021     MOVLB 0x1
0179  1691     BSF PIE1, 0x5
50:                RC1STAbits.CREN = 1;
017A  0023     MOVLB 0x3
017B  161D     BSF RC1STA, 0x4
51:            }
017C  0008     RETURN
52:            
53:            void processRxByte(void) {
54:                uint8_t byte;
55:                uint8_t parity;
56:                if (RC1STAbits.OERR == 1) {
0026  0023     MOVLB 0x3
0027  1C9D     BTFSS RC1STA, 0x1
0028  282A     GOTO 0x2A
0029  282B     GOTO 0x2B
002A  2830     GOTO 0x30
57:                    RC1STAbits.CREN = 0;
002B  121D     BCF RC1STA, 0x4
58:                    RC1STAbits.CREN = 1;
002C  161D     BSF RC1STA, 0x4
59:                    currentByte = 0;
002D  0020     MOVLB 0x0
002E  01BA     CLRF currentByte
60:                } else if (RC1STAbits.FERR == 1) {
002F  2891     GOTO 0x91
0030  1D1D     BTFSS TMR2, 0x2
0031  2833     GOTO 0x33
0032  2834     GOTO 0x34
0033  2836     GOTO 0x36
61:                    byte = RC1REG;
0034  0819     MOVF TMR1, W
0035  282D     GOTO 0x2D
62:                    currentByte = 0;
63:                } else {
64:                    parity = RC1STAbits.RX9D;
0036  081D     MOVF TMR2, W
65:                    byte = RC1REG;
0037  0819     MOVF TMR1, W
0038  00F0     MOVWF __pcstackCOMMON
0039  0870     MOVF __pcstackCOMMON, W
003A  00FC     MOVWF byte
66:                    if (receivingPacket) {
003B  0020     MOVLB 0x0
003C  0838     MOVF receivingPacket, W
003D  1903     BTFSC STATUS, 0x2
003E  2840     GOTO 0x40
003F  2841     GOTO 0x41
0040  2880     GOTO 0x80
67:                        if (currentByte == sizeof (rxPacket)) {
0041  3017     MOVLW 0x17
0042  063A     XORWF currentByte, W
0043  1D03     BTFSS STATUS, 0x2
0044  2846     GOTO 0x46
0045  2847     GOTO 0x47
0046  2873     GOTO 0x73
68:                            receivingPacket = 0;
0047  01B8     CLRF receivingPacket
69:                            throttle = ((uint16_t)rxPacket.channels[2]  >> 6 | (uint16_t)rxPacket.channels[3]  << 2  |
0048  0824     MOVF 0x24, W
0049  00F0     MOVWF __pcstackCOMMON
004A  01F1     CLRF 0x71
004B  300A     MOVLW 0xA
004C  35F0     LSLF __pcstackCOMMON, F
004D  0DF1     RLF 0x71, F
004E  0B89     DECFSZ WREG, F
004F  284C     GOTO 0x4C
0050  0823     MOVF 0x23, W
0051  00F2     MOVWF multiplicand
0052  01F3     CLRF 0x73
0053  35F2     LSLF multiplicand, F
0054  0DF3     RLF 0x73, F
0055  35F2     LSLF multiplicand, F
0056  0DF3     RLF 0x73, F
0057  0822     MOVF 0x22, W
0058  00F4     MOVWF product
0059  3006     MOVLW 0x6
005A  36F4     LSRF product, F
005B  0B89     DECFSZ WREG, F
005C  285A     GOTO 0x5A
005D  0872     MOVF multiplicand, W
005E  0474     IORWF product, W
005F  00F5     MOVWF 0x75
0060  0873     MOVF 0x73, W
0061  00F6     MOVWF 0x76
0062  0870     MOVF __pcstackCOMMON, W
0063  0475     IORWF 0x75, W
0064  00F7     MOVWF 0x77
0065  0871     MOVF 0x71, W
0066  0476     IORWF 0x76, W
0067  00F8     MOVWF 0x78
0068  30FF     MOVLW 0xFF
0069  0577     ANDWF 0x77, W
006A  00F9     MOVWF quotient
006B  3007     MOVLW 0x7
006C  0578     ANDWF 0x78, W
006D  00FA     MOVWF 0x7A
006E  0879     MOVF quotient, W
006F  00BC     MOVWF throttle
0070  087A     MOVF 0x7A, W
0071  00BD     MOVWF 0x3D
70:                          (uint16_t)rxPacket.channels[4] << 10) & 0x07ff;
71:                        } else {
0072  2891     GOTO 0x91
72:                            rxPacket.bytes[currentByte] = byte;
0073  087C     MOVF byte, W
0074  00F0     MOVWF __pcstackCOMMON
0075  083A     MOVF currentByte, W
0076  3E20     ADDLW 0x20
0077  0086     MOVWF FSR1
0078  0187     CLRF FSR1H
0079  0870     MOVF __pcstackCOMMON, W
007A  0081     MOVWF INDF1
73:                            ++currentByte;
007B  3001     MOVLW 0x1
007C  00F0     MOVWF __pcstackCOMMON
007D  0870     MOVF __pcstackCOMMON, W
007E  07BA     ADDWF currentByte, F
007F  2891     GOTO 0x91
74:                        }
75:                    } else {
76:                        if (tickCount >= 2 && byte == SBUS_HEADER) {
0080  3002     MOVLW 0x2
0081  023B     SUBWF tickCount, W
0082  1C03     BTFSS STATUS, 0x0
0083  2885     GOTO 0x85
0084  2886     GOTO 0x86
0085  2891     GOTO 0x91
0086  300F     MOVLW 0xF
0087  067C     XORWF byte, W
0088  1D03     BTFSS STATUS, 0x2
0089  288B     GOTO 0x8B
008A  288C     GOTO 0x8C
008B  2891     GOTO 0x91
77:                            receivingPacket = 1;
008C  3001     MOVLW 0x1
008D  00F0     MOVWF __pcstackCOMMON
008E  0870     MOVF __pcstackCOMMON, W
008F  00B8     MOVWF receivingPacket
0090  282D     GOTO 0x2D
78:                            currentByte = 0;
79:                        }
80:                    }
81:                }
82:                tickCount = 0;
0091  01BB     CLRF tickCount
83:            }
0092  0008     RETURN
---  C:/Projects/SBus-Decoder/Firmware/SBus-Decoder.X/main.c  -------------------------------------------
1:             /////////////////////////////////////////////////////
2:             // Project: SBus-Decoder                           //
3:             // File: main.c                                    //
4:             // Target: PIC16F18313                             // 
5:             // Compiler: XC8                                   //
6:             // Author: Brad McGarvey                           //
7:             // License: GNU General Public License v3.0        //
8:             // Description: main loop                          //
9:             /////////////////////////////////////////////////////
10:            
11:            #include <xc.h>
12:            #include <stdbool.h>
13:            #include <stdint.h>
14:            #include "sbus.h"
15:            #include "led.h"
16:            #include "timers.h"
17:            #include "servo.h"
18:            
19:            #define _XTAL_FREQ   32000000U
20:            
21:            void configPins(void);
22:            void configInterrupts(void);
23:            void configPMD(void);
24:            
25:            void main(void) {
26:                OSCTUNE = 0;
0132  0032     MOVLB 0x12
0133  019E     CLRF OSCTUNE
27:                configPins();
0134  3181     MOVLP 0x1
0135  219C     CALL 0x19C
0136  3181     MOVLP 0x1
28:                configPMD();
0137  3181     MOVLP 0x1
0138  21FE     CALL 0x1FE
0139  3181     MOVLP 0x1
29:                configInterrupts();
013A  3181     MOVLP 0x1
013B  21F8     CALL 0x1F8
013C  3181     MOVLP 0x1
30:                initServos();
013D  3181     MOVLP 0x1
013E  21E3     CALL 0x1E3
013F  3181     MOVLP 0x1
31:                initTimer1();
0140  3181     MOVLP 0x1
0141  21DB     CALL 0x1DB
0142  3181     MOVLP 0x1
32:                initTimer2();
0143  3181     MOVLP 0x1
0144  21CA     CALL 0x1CA
0145  3181     MOVLP 0x1
33:                startTimer2();
0146  3181     MOVLP 0x1
0147  21F5     CALL 0x1F5
0148  3181     MOVLP 0x1
34:                initSBus();
0149  3181     MOVLP 0x1
014A  215D     CALL 0x15D
014B  3181     MOVLP 0x1
35:                while (1) {
36:                    if (throttle > 1024) {
014C  3004     MOVLW 0x4
014D  0020     MOVLB 0x0
014E  023D     SUBWF 0x3D, W
014F  3001     MOVLW 0x1
0150  1903     BTFSC STATUS, 0x2
0151  023C     SUBWF throttle, W
0152  1C03     BTFSS STATUS, 0x0
0153  2955     GOTO 0x155
0154  2956     GOTO 0x156
0155  2959     GOTO 0x159
37:                        ledOn();
0156  0022     MOVLB 0x2
0157  150C     BSF LATA, 0x2
38:                    } else {
0158  294C     GOTO 0x14C
39:                        ledOff();
0159  0022     MOVLB 0x2
015A  110C     BCF LATA, 0x2
015B  294C     GOTO 0x14C
40:                    }
41:                }
42:            }
43:            
44:            void configPins(void) {
45:                ANSELA = 0;
019C  0023     MOVLB 0x3
019D  018C     CLRF ANSELA
46:                LATA = 0b00000000;
019E  0022     MOVLB 0x2
019F  018C     CLRF LATA
47:                TRISA = 0b00101000;
01A0  3028     MOVLW 0x28
01A1  0021     MOVLB 0x1
01A2  008C     MOVWF TRISA
48:                RXPPS = 0b00101; //RA5
01A3  3005     MOVLW 0x5
01A4  003C     MOVLB 0x1C
01A5  00A4     MOVWF RXPPS
49:                CLCIN0PPS = 0b00011; //RA3
01A6  3003     MOVLW 0x3
01A7  00A8     MOVWF CLCIN0PPS
50:                RA4PPS = 0b00100; //CLC1OUT
01A8  3004     MOVLW 0x4
01A9  003D     MOVLB 0x1D
01AA  0094     MOVWF RA4PPS
51:                RA0PPS = 0b01100; //CCP1
01AB  300C     MOVLW 0xC
01AC  0090     MOVWF RA0PPS
52:                RA1PPS = 0b01101; //CCP2
01AD  300D     MOVLW 0xD
01AE  0091     MOVWF RA1PPS
53:                PPSLOCK = 0x55;
01AF  3055     MOVLW 0x55
01B0  003C     MOVLB 0x1C
01B1  008F     MOVWF PPSLOCK
54:                PPSLOCK = 0xaa;
01B2  30AA     MOVLW 0xAA
01B3  008F     MOVWF PPSLOCK
55:                PPSLOCKbits.PPSLOCKED = 1;
01B4  140F     BSF PPSLOCK, 0x0
56:            }
01B5  0008     RETURN
57:            
58:            void configInterrupts(void) {
59:                INTCONbits.PEIE = 1;
01F8  170B     BSF INTCON, 0x6
60:                INTCONbits.GIE = 1;
01F9  178B     BSF INTCON, 0x7
61:            }
01FA  0008     RETURN
62:            
63:            void configPMD(void) {
64:                /*
65:                PMD0 = 0b01000111;
66:                PMD1 = 0b10000001;
67:                PMD2 = 0b01100110;
68:                PMD3 = 0b01110011;
69:                PMD4 = 0b00100010;
70:                PMD5 = 0b00000111;
71:                 */
72:            }
01FE  0008     RETURN
73:            
74:            void __interrupt() isr(void) {
0004  147E     BSF 0xE7E, 0x0
0005  3180     MOVLP 0x0
75:                while (PIR1bits.RCIF == 1) {
0006  280A     GOTO 0xA
000A  0020     MOVLB 0x0
000B  1A91     BTFSC PIR1, 0x5
000C  280E     GOTO 0xE
000D  280F     GOTO 0xF
000E  2807     GOTO 0x7
76:                    processRxByte();
0007  3180     MOVLP 0x0
0008  2026     CALL 0x26
0009  3180     MOVLP 0x0
77:                }
78:                if (PIR1bits.TMR2IF == 1) {
000F  1C91     BTFSS PIR1, 0x1
0010  2812     GOTO 0x12
0011  2813     GOTO 0x13
0012  2818     GOTO 0x18
79:                    handleTimer2Int();
0013  3181     MOVLP 0x1
0014  21B6     CALL 0x1B6
0015  3180     MOVLP 0x0
80:                    PIR1bits.TMR2IF = 0;
0016  0020     MOVLB 0x0
0017  1091     BCF PIR1, 0x1
81:                }
82:            }
0018  107E     BCF 0x7E, 0x0
---  C:/Program Files/Microchip/xc8/v2.31/pic/sources/c99/common/__lldiv.c  -----------------------------
1:             // long unsigned unsigned division
2:             
3:             unsigned long int
4:             #ifdef __PICC__
5:             __lldiv(unsigned long int divisor, unsigned long int dividend)
6:             #else
7:             __lldiv(unsigned long int dividend, unsigned long int divisor)
8:             #endif
9:             {
10:            	unsigned long int	quotient;
11:            	unsigned char	counter;
12:            
13:            	quotient = 0;
0093  3000     MOVLW 0x0
0094  00FC     MOVWF byte
0095  3000     MOVLW 0x0
0096  00FB     MOVWF 0x7B
0097  3000     MOVLW 0x0
0098  00FA     MOVWF 0x7A
0099  3000     MOVLW 0x0
009A  00F9     MOVWF quotient
14:            	if(divisor != 0) {
009B  0873     MOVF 0x73, W
009C  0472     IORWF multiplicand, W
009D  0471     IORWF 0x71, W
009E  0470     IORWF __pcstackCOMMON, W
009F  1903     BTFSC STATUS, 0x2
00A0  28A2     GOTO 0xA2
00A1  28A3     GOTO 0xA3
00A2  28E4     GOTO 0xE4
15:            		counter = 1;
00A3  01FD     CLRF counter
00A4  0AFD     INCF counter, F
16:            		while((divisor & 0x80000000UL) == 0) {
00A5  28B1     GOTO 0xB1
00B1  1FF3     BTFSS 0x73, 0x7
00B2  28B4     GOTO 0xB4
00B3  28B5     GOTO 0xB5
00B4  28A6     GOTO 0xA6
17:            			divisor <<= 1;
00A6  3001     MOVLW 0x1
00A7  35F0     LSLF __pcstackCOMMON, F
00A8  0DF1     RLF 0x71, F
00A9  0DF2     RLF multiplicand, F
00AA  0DF3     RLF 0x73, F
00AB  0B89     DECFSZ WREG, F
00AC  28A7     GOTO 0xA7
18:            			counter++;
00AD  3001     MOVLW 0x1
00AE  00F8     MOVWF 0x78
00AF  0878     MOVF 0x78, W
00B0  07FD     ADDWF counter, F
19:            		}
20:            		do {
21:            			quotient <<= 1;
00B5  3001     MOVLW 0x1
00B6  35F9     LSLF quotient, F
00B7  0DFA     RLF 0x7A, F
00B8  0DFB     RLF 0x7B, F
00B9  0DFC     RLF byte, F
00BA  0B89     DECFSZ WREG, F
00BB  28B6     GOTO 0xB6
22:            			if(divisor <= dividend) {
00BC  0873     MOVF 0x73, W
00BD  0277     SUBWF 0x77, W
00BE  1D03     BTFSS STATUS, 0x2
00BF  28CA     GOTO 0xCA
00C0  0872     MOVF multiplicand, W
00C1  0276     SUBWF 0x76, W
00C2  1D03     BTFSS STATUS, 0x2
00C3  28CA     GOTO 0xCA
00C4  0871     MOVF 0x71, W
00C5  0275     SUBWF 0x75, W
00C6  1D03     BTFSS STATUS, 0x2
00C7  28CA     GOTO 0xCA
00C8  0870     MOVF __pcstackCOMMON, W
00C9  0274     SUBWF product, W
00CA  1C03     BTFSS STATUS, 0x0
00CB  28CD     GOTO 0xCD
00CC  28CE     GOTO 0xCE
00CD  28D7     GOTO 0xD7
23:            				dividend -= divisor;
00CE  0870     MOVF __pcstackCOMMON, W
00CF  02F4     SUBWF product, F
00D0  0871     MOVF 0x71, W
00D1  3BF5     SUBWFB 0x75, F
00D2  0872     MOVF multiplicand, W
00D3  3BF6     SUBWFB 0x76, F
00D4  0873     MOVF 0x73, W
00D5  3BF7     SUBWFB 0x77, F
24:            				quotient |= 1;
00D6  1479     BSF quotient, 0x0
25:            			}
26:            			divisor >>= 1;
00D7  3001     MOVLW 0x1
00D8  36F3     LSRF 0x73, F
00D9  0CF2     RRF multiplicand, F
00DA  0CF1     RRF 0x71, F
00DB  0CF0     RRF __pcstackCOMMON, F
00DC  0B89     DECFSZ WREG, F
00DD  28D8     GOTO 0xD8
27:            		} while(--counter != 0);
00DE  3001     MOVLW 0x1
00DF  02FD     SUBWF counter, F
00E0  1D03     BTFSS STATUS, 0x2
00E1  28E3     GOTO 0xE3
00E2  28E4     GOTO 0xE4
00E3  28B5     GOTO 0xB5
28:            	}
29:            	return quotient;
00E4  087C     MOVF byte, W
00E5  00F3     MOVWF 0x73
00E6  087B     MOVF 0x7B, W
00E7  00F2     MOVWF multiplicand
00E8  087A     MOVF 0x7A, W
00E9  00F1     MOVWF 0x71
00EA  0879     MOVF quotient, W
00EB  00F0     MOVWF __pcstackCOMMON
30:            }
00EC  0008     RETURN
---  C:/Program Files/Microchip/xc8/v2.31/pic/sources/c99/common/Umul16.c  ------------------------------
1:             // 16 x 16 bit multiplication with 16 bit result
2:             #ifdef _PIC18
3:             #define _Has_hardware_multiply 1
4:             #else
5:             #define _Has_hardware_multiply 0
6:             #endif
7:             
8:             #if defined(_PIC14E) || defined(_PIC14EX) || defined(_PIC18)
9:             #define _Has_large_call_stack 1
10:            #else
11:            #define _Has_large_call_stack 0
12:            #endif
13:            
14:            unsigned int
15:            __wmul(unsigned int multiplier, unsigned int multiplicand)
16:            {
17:                    unsigned int product;
18:            
19:            #if _Has_hardware_multiply || _Has_large_call_stack
20:            
21:            #define LOWBYTE(x)  (*(unsigned char *)(&x))
22:            #define HIGHBYTE(x) (*(((unsigned char *)(&x))+1))
23:            
24:            	// optimized to allow use of the 8 x 8 bit hardware multiply instruction
25:            /*
26:            a 16-bit multiply can be decomposed into the sum of three 8-bit multiplies
27:                   a  b
28:            *      c  d
29:            -----------
30:                 |   bd
31:                 |ad  0
32:                 |bc  0
33:            +  ac| 0  0 (we ignore this intermediate product
34:                         because it does not affect the low 16 bits of the result)
35:            ===========
36:             */
37:                    product =  LOWBYTE(multiplier) * LOWBYTE(multiplicand);
38:                    product += (unsigned int)(LOWBYTE(multiplier) * HIGHBYTE(multiplicand)) << 8;
39:                    product += (unsigned int)(HIGHBYTE(multiplier) * LOWBYTE(multiplicand)) << 8;
40:            
41:            #else
42:            
43:            	product = 0;
017D  01F4     CLRF product
017E  01F5     CLRF 0x75
44:            	do {
45:            		if(multiplier & 1)
017F  1C70     BTFSS __pcstackCOMMON, 0x0
0180  2982     GOTO 0x182
0181  2983     GOTO 0x183
0182  2987     GOTO 0x187
46:            			product += multiplicand;
0183  0872     MOVF multiplicand, W
0184  07F4     ADDWF product, F
0185  0873     MOVF 0x73, W
0186  3DF5     ADDWFC 0x75, F
47:            		multiplicand <<= 1;
0187  3001     MOVLW 0x1
0188  35F2     LSLF multiplicand, F
0189  0DF3     RLF 0x73, F
018A  0B89     DECFSZ WREG, F
018B  2988     GOTO 0x188
48:            		multiplier >>= 1;
018C  3001     MOVLW 0x1
018D  36F1     LSRF 0x71, F
018E  0CF0     RRF __pcstackCOMMON, F
018F  0B89     DECFSZ WREG, F
0190  298D     GOTO 0x18D
49:            	} while(multiplier != 0);
0191  0870     MOVF __pcstackCOMMON, W
0192  0471     IORWF 0x71, W
0193  1D03     BTFSS STATUS, 0x2
0194  2996     GOTO 0x196
0195  2997     GOTO 0x197
0196  297F     GOTO 0x17F
50:            
51:            #endif
52:                    return product;
0197  0875     MOVF 0x75, W
0198  00F1     MOVWF 0x71
0199  0874     MOVF product, W
019A  00F0     MOVWF __pcstackCOMMON
53:            }
019B  0008     RETURN
